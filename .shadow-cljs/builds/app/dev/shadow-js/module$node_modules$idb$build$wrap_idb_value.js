["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/idb/build/wrap-idb-value.js"],"~:js","shadow$provide.module$node_modules$idb$build$wrap_idb_value=function(global,require,module,exports){function promisifyRequest(request){const promise=new Promise((resolve,reject)=>{const unlisten=()=>{request.removeEventListener(\"success\",success);request.removeEventListener(\"error\",error)},success=()=>{resolve(wrap(request.result));unlisten()},error=()=>{reject(request.error);unlisten()};request.addEventListener(\"success\",success);request.addEventListener(\"error\",error)});promise.then(value=>{value instanceof\nIDBCursor&&cursorRequestMap.set(value,request)}).catch(()=>{});reverseTransformCache.set(promise,request);return promise}function cacheDonePromiseForTransaction(tx){if(!transactionDoneMap.has(tx)){var done=new Promise((resolve,reject)=>{const unlisten=()=>{tx.removeEventListener(\"complete\",complete);tx.removeEventListener(\"error\",error);tx.removeEventListener(\"abort\",error)},complete=()=>{resolve();unlisten()},error=()=>{reject(tx.error||new DOMException(\"AbortError\",\"AbortError\"));unlisten()};tx.addEventListener(\"complete\",\ncomplete);tx.addEventListener(\"error\",error);tx.addEventListener(\"abort\",error)});transactionDoneMap.set(tx,done)}}function wrapFunction(func){return func!==IDBDatabase.prototype.transaction||\"objectStoreNames\"in IDBTransaction.prototype?(cursorAdvanceMethods||(cursorAdvanceMethods=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(func)?function(...args){func.apply(reverseTransformCache.get(this),args);return wrap(cursorRequestMap.get(this))}:\nfunction(...args){return wrap(func.apply(reverseTransformCache.get(this),args))}:function(storeNames,...args){args=func.call(reverseTransformCache.get(this),storeNames,...args);transactionStoreNamesMap.set(args,storeNames.sort?storeNames.sort():[storeNames]);return wrap(args)}}function wrap(value){if(value instanceof IDBRequest)return promisifyRequest(value);if(transformCache.has(value))return transformCache.get(value);if(\"function\"===typeof value)var JSCompiler_inline_result=wrapFunction(value);\nelse value instanceof IDBTransaction&&cacheDonePromiseForTransaction(value),JSCompiler_inline_result=instanceOfAny(value,idbProxyableTypes||(idbProxyableTypes=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction]))?new Proxy(value,idbProxyTraps):value;JSCompiler_inline_result!==value&&(transformCache.set(value,JSCompiler_inline_result),reverseTransformCache.set(JSCompiler_inline_result,value));return JSCompiler_inline_result}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.r=\nfunction(callback){idbProxyTraps=callback(idbProxyTraps)};exports.w=wrap;exports.u=exports.i=exports.a=void 0;const instanceOfAny=(object,constructors)=>constructors.some(c=>object instanceof c);exports.i=instanceOfAny;let idbProxyableTypes,cursorAdvanceMethods;const cursorRequestMap=new WeakMap,transactionDoneMap=new WeakMap,transactionStoreNamesMap=new WeakMap,transformCache=new WeakMap,reverseTransformCache=new WeakMap;exports.a=reverseTransformCache;let idbProxyTraps={get(target,prop,receiver){if(target instanceof\nIDBTransaction){if(\"done\"===prop)return transactionDoneMap.get(target);if(\"objectStoreNames\"===prop)return target.objectStoreNames||transactionStoreNamesMap.get(target);if(\"store\"===prop)return receiver.objectStoreNames[1]?void 0:receiver.objectStore(receiver.objectStoreNames[0])}return wrap(target[prop])},set(target,prop,value){target[prop]=value;return!0},has(target,prop){return target instanceof IDBTransaction&&(\"done\"===prop||\"store\"===prop)?!0:prop in target}};exports.u=value=>reverseTransformCache.get(value)}","~:source","shadow$provide[\"module$node_modules$idb$build$wrap_idb_value\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.r = replaceTraps;\nexports.w = wrap;\nexports.u = exports.i = exports.a = void 0;\n\nconst instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nexports.i = instanceOfAny;\nlet idbProxyableTypes;\nlet cursorAdvanceMethods; // This is a function to prevent it throwing up in node environments.\n\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n} // This is a function to prevent it throwing up in node environments.\n\n\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n}\n\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nexports.a = reverseTransformCache;\n\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  promise.then(value => {\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n    // (see wrapFunction).\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    } // Catching to avoid \"Uncaught Promise exceptions\"\n\n  }).catch(() => {}); // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\n\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n\n    const error = () => {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  }); // Cache it for later retrieval.\n\n  transactionDoneMap.set(tx, done);\n}\n\nlet idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target); // Polyfill for objectStoreNames because of Edge.\n\n      if (prop === 'objectStoreNames') {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      } // Make tx.store return the only store in the transaction, or undefined if there are many.\n\n\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    } // Else transform whatever we get back.\n\n\n    return wrap(target[prop]);\n  },\n\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n\n    return prop in target;\n  }\n\n};\n\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\n\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n    return function (storeNames, ...args) {\n      const tx = func.call(unwrap(this), storeNames, ...args);\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  } // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n\n\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function (...args) {\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n\n  return function (...args) {\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\n\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value); // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps); // Return the same value back if we're not going to transform it.\n\n  return value;\n}\n\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value); // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n\n  if (transformCache.has(value)) return transformCache.get(value);\n  const newValue = transformCachableValue(value); // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n\n  return newValue;\n}\n\nconst unwrap = value => reverseTransformCache.get(value);\n\nexports.u = unwrap;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["w","__esModule","value","a","i","r","u"]],"~:compiled-at",1666337898748,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$idb$build$wrap_idb_value.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/idb/build/wrap-idb-value.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$idb$build$wrap_idb_value\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.r = replaceTraps;\\nexports.w = wrap;\\nexports.u = exports.i = exports.a = void 0;\\n\\nconst instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\\n\\nexports.i = instanceOfAny;\\nlet idbProxyableTypes;\\nlet cursorAdvanceMethods; // This is a function to prevent it throwing up in node environments.\\n\\nfunction getIdbProxyableTypes() {\\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\\n} // This is a function to prevent it throwing up in node environments.\\n\\n\\nfunction getCursorAdvanceMethods() {\\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\\n}\\n\\nconst cursorRequestMap = new WeakMap();\\nconst transactionDoneMap = new WeakMap();\\nconst transactionStoreNamesMap = new WeakMap();\\nconst transformCache = new WeakMap();\\nconst reverseTransformCache = new WeakMap();\\nexports.a = reverseTransformCache;\\n\\nfunction promisifyRequest(request) {\\n  const promise = new Promise((resolve, reject) => {\\n    const unlisten = () => {\\n      request.removeEventListener('success', success);\\n      request.removeEventListener('error', error);\\n    };\\n\\n    const success = () => {\\n      resolve(wrap(request.result));\\n      unlisten();\\n    };\\n\\n    const error = () => {\\n      reject(request.error);\\n      unlisten();\\n    };\\n\\n    request.addEventListener('success', success);\\n    request.addEventListener('error', error);\\n  });\\n  promise.then(value => {\\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\\n    // (see wrapFunction).\\n    if (value instanceof IDBCursor) {\\n      cursorRequestMap.set(value, request);\\n    } // Catching to avoid \\\"Uncaught Promise exceptions\\\"\\n\\n  }).catch(() => {}); // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\\n  // is because we create many promises from a single IDBRequest.\\n\\n  reverseTransformCache.set(promise, request);\\n  return promise;\\n}\\n\\nfunction cacheDonePromiseForTransaction(tx) {\\n  // Early bail if we've already created a done promise for this transaction.\\n  if (transactionDoneMap.has(tx)) return;\\n  const done = new Promise((resolve, reject) => {\\n    const unlisten = () => {\\n      tx.removeEventListener('complete', complete);\\n      tx.removeEventListener('error', error);\\n      tx.removeEventListener('abort', error);\\n    };\\n\\n    const complete = () => {\\n      resolve();\\n      unlisten();\\n    };\\n\\n    const error = () => {\\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\\n      unlisten();\\n    };\\n\\n    tx.addEventListener('complete', complete);\\n    tx.addEventListener('error', error);\\n    tx.addEventListener('abort', error);\\n  }); // Cache it for later retrieval.\\n\\n  transactionDoneMap.set(tx, done);\\n}\\n\\nlet idbProxyTraps = {\\n  get(target, prop, receiver) {\\n    if (target instanceof IDBTransaction) {\\n      // Special handling for transaction.done.\\n      if (prop === 'done') return transactionDoneMap.get(target); // Polyfill for objectStoreNames because of Edge.\\n\\n      if (prop === 'objectStoreNames') {\\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\\n      } // Make tx.store return the only store in the transaction, or undefined if there are many.\\n\\n\\n      if (prop === 'store') {\\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\\n      }\\n    } // Else transform whatever we get back.\\n\\n\\n    return wrap(target[prop]);\\n  },\\n\\n  set(target, prop, value) {\\n    target[prop] = value;\\n    return true;\\n  },\\n\\n  has(target, prop) {\\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\\n      return true;\\n    }\\n\\n    return prop in target;\\n  }\\n\\n};\\n\\nfunction replaceTraps(callback) {\\n  idbProxyTraps = callback(idbProxyTraps);\\n}\\n\\nfunction wrapFunction(func) {\\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\\n  // only create one new func per func.\\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\\n    return function (storeNames, ...args) {\\n      const tx = func.call(unwrap(this), storeNames, ...args);\\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\\n      return wrap(tx);\\n    };\\n  } // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\\n  // undefined if the end of the cursor has been reached.\\n\\n\\n  if (getCursorAdvanceMethods().includes(func)) {\\n    return function (...args) {\\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\\n      // the original object.\\n      func.apply(unwrap(this), args);\\n      return wrap(cursorRequestMap.get(this));\\n    };\\n  }\\n\\n  return function (...args) {\\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\\n    // the original object.\\n    return wrap(func.apply(unwrap(this), args));\\n  };\\n}\\n\\nfunction transformCachableValue(value) {\\n  if (typeof value === 'function') return wrapFunction(value); // This doesn't return, it just creates a 'done' promise for the transaction,\\n  // which is later returned for transaction.done (see idbObjectHandler).\\n\\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps); // Return the same value back if we're not going to transform it.\\n\\n  return value;\\n}\\n\\nfunction wrap(value) {\\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\\n  if (value instanceof IDBRequest) return promisifyRequest(value); // If we've already transformed this value before, reuse the transformed value.\\n  // This is faster, but it also provides object equality.\\n\\n  if (transformCache.has(value)) return transformCache.get(value);\\n  const newValue = transformCachableValue(value); // Not all types are transformed.\\n  // These may be primitive types, so they can't be WeakMap keys.\\n\\n  if (newValue !== value) {\\n    transformCache.set(value, newValue);\\n    reverseTransformCache.set(newValue, value);\\n  }\\n\\n  return newValue;\\n}\\n\\nconst unwrap = value => reverseTransformCache.get(value);\\n\\nexports.u = unwrap;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"promisifyRequest\",\"request\",\"promise\",\"Promise\",\"resolve\",\"reject\",\"unlisten\",\"removeEventListener\",\"success\",\"error\",\"wrap\",\"result\",\"addEventListener\",\"then\",\"value\",\"IDBCursor\",\"cursorRequestMap\",\"set\",\"catch\",\"reverseTransformCache\",\"cacheDonePromiseForTransaction\",\"tx\",\"transactionDoneMap\",\"has\",\"done\",\"complete\",\"DOMException\",\"wrapFunction\",\"func\",\"IDBDatabase\",\"prototype\",\"transaction\",\"IDBTransaction\",\"includes\",\"cursorAdvanceMethods\",\"advance\",\"continue\",\"continuePrimaryKey\",\"args\",\"apply\",\"get\",\"storeNames\",\"call\",\"transactionStoreNamesMap\",\"sort\",\"IDBRequest\",\"transformCache\",\"instanceOfAny\",\"idbProxyableTypes\",\"IDBObjectStore\",\"IDBIndex\",\"Proxy\",\"idbProxyTraps\",\"newValue\",\"Object\",\"defineProperty\",\"r\",\"replaceTraps\",\"callback\",\"w\",\"u\",\"i\",\"a\",\"object\",\"constructors\",\"some\",\"c\",\"WeakMap\",\"target\",\"prop\",\"receiver\",\"objectStoreNames\",\"undefined\",\"objectStore\",\"unwrap\"]\n}\n"]