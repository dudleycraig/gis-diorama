["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/babel-polyfill/node_modules/core-js/modules/_fix-re-wks.js"],"~:js","shadow$provide.module$node_modules$babel_polyfill$node_modules$core_js$modules$_fix_re_wks=function(global,require,module,exports){require(\"module$node_modules$babel_polyfill$node_modules$core_js$modules$es6_regexp_exec\");var redefine=require(\"module$node_modules$babel_polyfill$node_modules$core_js$modules$_redefine\"),hide=require(\"module$node_modules$babel_polyfill$node_modules$core_js$modules$_hide\"),fails=require(\"module$node_modules$babel_polyfill$node_modules$core_js$modules$_fails\"),defined=\nrequire(\"module$node_modules$babel_polyfill$node_modules$core_js$modules$_defined\"),wks=require(\"module$node_modules$babel_polyfill$node_modules$core_js$modules$_wks\"),regexpExec=require(\"module$node_modules$babel_polyfill$node_modules$core_js$modules$_regexp_exec\"),SPECIES=wks(\"species\"),REPLACE_SUPPORTS_NAMED_GROUPS=!fails(function(){var re=/./;re.exec=function(){var result=[];result.groups={a:\"7\"};return result};return\"7\"!==\"\".replace(re,\"$\\x3ca\\x3e\")}),SPLIT_WORKS_WITH_OVERWRITTEN_EXEC=function(){var re=\n/(?:)/,originalExec=re.exec;re.exec=function(){return originalExec.apply(this,arguments)};re=\"ab\".split(re);return 2===re.length&&\"a\"===re[0]&&\"b\"===re[1]}();module.exports=function(KEY,length,exec){var SYMBOL=wks(KEY),DELEGATES_TO_SYMBOL=!fails(function(){var O={};O[SYMBOL]=function(){return 7};return 7!=\"\"[KEY](O)}),DELEGATES_TO_EXEC=DELEGATES_TO_SYMBOL?!fails(function(){var execCalled=!1,re=/a/;re.exec=function(){execCalled=!0;return null};\"split\"===KEY&&(re.constructor={},re.constructor[SPECIES]=\nfunction(){return re});re[SYMBOL](\"\");return!execCalled}):void 0;if(!DELEGATES_TO_SYMBOL||!DELEGATES_TO_EXEC||\"replace\"===KEY&&!REPLACE_SUPPORTS_NAMED_GROUPS||\"split\"===KEY&&!SPLIT_WORKS_WITH_OVERWRITTEN_EXEC){var nativeRegExpMethod=/./[SYMBOL];exec=exec(defined,SYMBOL,\"\"[KEY],function(nativeMethod,regexp,str,arg2,forceStringMethod){return regexp.exec===regexpExec?DELEGATES_TO_SYMBOL&&!forceStringMethod?{done:!0,value:nativeRegExpMethod.call(regexp,str,arg2)}:{done:!0,value:nativeMethod.call(str,\nregexp,arg2)}:{done:!1}});var rxfn=exec[1];redefine(String.prototype,KEY,exec[0]);hide(RegExp.prototype,SYMBOL,2==length?function(string,arg){return rxfn.call(string,this,arg)}:function(string){return rxfn.call(string,this)})}}}","~:source","shadow$provide[\"module$node_modules$babel_polyfill$node_modules$core_js$modules$_fix_re_wks\"] = function(global,require,module,exports) {\n'use strict';\nrequire('./es6.regexp.exec');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar fails = require('./_fails');\nvar defined = require('./_defined');\nvar wks = require('./_wks');\nvar regexpExec = require('./_regexp-exec');\n\nvar SPECIES = wks('species');\n\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  // #replace needs built-in support for named groups.\n  // #match works fine because it just return the exec results, even if it has\n  // a \"grops\" property.\n  var re = /./;\n  re.exec = function () {\n    var result = [];\n    result.groups = { a: '7' };\n    return result;\n  };\n  return ''.replace(re, '$<a>') !== '7';\n});\n\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {\n  // Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length === 2 && result[0] === 'a' && result[1] === 'b';\n})();\n\nmodule.exports = function (KEY, length, exec) {\n  var SYMBOL = wks(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n    re.exec = function () { execCalled = true; return null; };\n    if (KEY === 'split') {\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n    }\n    re[SYMBOL]('');\n    return !execCalled;\n  }) : undefined;\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||\n    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)\n  ) {\n    var nativeRegExpMethod = /./[SYMBOL];\n    var fns = exec(\n      defined,\n      SYMBOL,\n      ''[KEY],\n      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {\n        if (regexp.exec === regexpExec) {\n          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n            // The native String method already delegates to @@method (this\n            // polyfilled function), leasing to infinite recursion.\n            // We avoid it by directly calling the native @@method method.\n            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\n          }\n          return { done: true, value: nativeMethod.call(str, regexp, arg2) };\n        }\n        return { done: false };\n      }\n    );\n    var strfn = fns[0];\n    var rxfn = fns[1];\n\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return rxfn.call(string, this); }\n    );\n  }\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$babel_polyfill$node_modules$core_js$modules$_defined","~$module$node_modules$babel_polyfill$node_modules$core_js$modules$_fails","~$module$node_modules$babel_polyfill$node_modules$core_js$modules$_regexp_exec","~$module$node_modules$babel_polyfill$node_modules$core_js$modules$es6_regexp_exec","~$shadow.js","~$module$node_modules$babel_polyfill$node_modules$core_js$modules$_wks","~$module$node_modules$babel_polyfill$node_modules$core_js$modules$_redefine","~$module$node_modules$babel_polyfill$node_modules$core_js$modules$_hide"]],"~:properties",["^5",["exec","value","a","done","groups","constructor"]],"~:compiled-at",1666267695846,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$babel_polyfill$node_modules$core_js$modules$_fix_re_wks.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/babel-polyfill/node_modules/core-js/modules/_fix-re-wks.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$babel_polyfill$node_modules$core_js$modules$_fix_re_wks\\\"] = function(global,require,module,exports) {\\n'use strict';\\nrequire('./es6.regexp.exec');\\nvar redefine = require('./_redefine');\\nvar hide = require('./_hide');\\nvar fails = require('./_fails');\\nvar defined = require('./_defined');\\nvar wks = require('./_wks');\\nvar regexpExec = require('./_regexp-exec');\\n\\nvar SPECIES = wks('species');\\n\\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\\n  // #replace needs built-in support for named groups.\\n  // #match works fine because it just return the exec results, even if it has\\n  // a \\\"grops\\\" property.\\n  var re = /./;\\n  re.exec = function () {\\n    var result = [];\\n    result.groups = { a: '7' };\\n    return result;\\n  };\\n  return ''.replace(re, '$<a>') !== '7';\\n});\\n\\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {\\n  // Chrome 51 has a buggy \\\"split\\\" implementation when RegExp#exec !== nativeExec\\n  var re = /(?:)/;\\n  var originalExec = re.exec;\\n  re.exec = function () { return originalExec.apply(this, arguments); };\\n  var result = 'ab'.split(re);\\n  return result.length === 2 && result[0] === 'a' && result[1] === 'b';\\n})();\\n\\nmodule.exports = function (KEY, length, exec) {\\n  var SYMBOL = wks(KEY);\\n\\n  var DELEGATES_TO_SYMBOL = !fails(function () {\\n    // String methods call symbol-named RegEp methods\\n    var O = {};\\n    O[SYMBOL] = function () { return 7; };\\n    return ''[KEY](O) != 7;\\n  });\\n\\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {\\n    // Symbol-named RegExp methods call .exec\\n    var execCalled = false;\\n    var re = /a/;\\n    re.exec = function () { execCalled = true; return null; };\\n    if (KEY === 'split') {\\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\\n      // a new one. We need to return the patched regex when creating the new one.\\n      re.constructor = {};\\n      re.constructor[SPECIES] = function () { return re; };\\n    }\\n    re[SYMBOL]('');\\n    return !execCalled;\\n  }) : undefined;\\n\\n  if (\\n    !DELEGATES_TO_SYMBOL ||\\n    !DELEGATES_TO_EXEC ||\\n    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||\\n    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)\\n  ) {\\n    var nativeRegExpMethod = /./[SYMBOL];\\n    var fns = exec(\\n      defined,\\n      SYMBOL,\\n      ''[KEY],\\n      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {\\n        if (regexp.exec === regexpExec) {\\n          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\\n            // The native String method already delegates to @@method (this\\n            // polyfilled function), leasing to infinite recursion.\\n            // We avoid it by directly calling the native @@method method.\\n            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\\n          }\\n          return { done: true, value: nativeMethod.call(str, regexp, arg2) };\\n        }\\n        return { done: false };\\n      }\\n    );\\n    var strfn = fns[0];\\n    var rxfn = fns[1];\\n\\n    redefine(String.prototype, KEY, strfn);\\n    hide(RegExp.prototype, SYMBOL, length == 2\\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\\n      // 21.2.5.6 RegExp.prototype[@@match](string)\\n      // 21.2.5.9 RegExp.prototype[@@search](string)\\n      : function (string) { return rxfn.call(string, this); }\\n    );\\n  }\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"redefine\",\"hide\",\"fails\",\"defined\",\"wks\",\"regexpExec\",\"SPECIES\",\"REPLACE_SUPPORTS_NAMED_GROUPS\",\"re\",\"exec\",\"re.exec\",\"result\",\"groups\",\"a\",\"replace\",\"SPLIT_WORKS_WITH_OVERWRITTEN_EXEC\",\"originalExec\",\"apply\",\"arguments\",\"split\",\"length\",\"module.exports\",\"KEY\",\"SYMBOL\",\"DELEGATES_TO_SYMBOL\",\"O\",\"DELEGATES_TO_EXEC\",\"execCalled\",\"constructor\",\"undefined\",\"nativeRegExpMethod\",\"fns\",\"maybeCallNative\",\"nativeMethod\",\"regexp\",\"str\",\"arg2\",\"forceStringMethod\",\"done\",\"value\",\"call\",\"rxfn\",\"String\",\"prototype\",\"strfn\",\"RegExp\",\"string\",\"arg\"]\n}\n"]