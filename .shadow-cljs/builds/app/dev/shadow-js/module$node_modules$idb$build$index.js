["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/idb/build/index.js"],"~:js","shadow$provide.module$node_modules$idb$build$index=function(global,require,module,exports){function getMethod(target$jscomp$0,prop){if(target$jscomp$0 instanceof IDBDatabase&&!(prop in target$jscomp$0)&&\"string\"===typeof prop){if(cachedMethods.get(prop))return cachedMethods.get(prop);var targetFuncName=prop.replace(/FromIndex$/,\"\"),useIndex=prop!==targetFuncName,isWrite=writeMethods.includes(targetFuncName);if(targetFuncName in(useIndex?IDBIndex:IDBObjectStore).prototype&&(isWrite||readMethods.includes(targetFuncName)))return target$jscomp$0=\nfunction(storeName,...args){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const tx=$jscomp$async$this.transaction(storeName,isWrite?\"readwrite\":\"readonly\");let target=tx.store;useIndex&&(target=target.index(args.shift()));return(yield Promise.all([target[targetFuncName](...args),isWrite&&tx.done]))[0]})},cachedMethods.set(prop,target$jscomp$0),target$jscomp$0}}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.deleteDB=function(name,{blocked}=\n{}){name=indexedDB.deleteDatabase(name);blocked&&name.addEventListener(\"blocked\",()=>blocked());return(0,_wrapIdbValue.w)(name).then(()=>{})};exports.openDB=function(name,version,{blocked,upgrade,blocking,terminated}={}){const request=indexedDB.open(name,version);name=(0,_wrapIdbValue.w)(request);upgrade&&request.addEventListener(\"upgradeneeded\",event=>{upgrade((0,_wrapIdbValue.w)(request.result),event.oldVersion,event.newVersion,(0,_wrapIdbValue.w)(request.transaction))});blocked&&request.addEventListener(\"blocked\",\n()=>blocked());name.then(db=>{terminated&&db.addEventListener(\"close\",()=>terminated());blocking&&db.addEventListener(\"versionchange\",()=>blocking())}).catch(()=>{});return name};Object.defineProperty(exports,\"unwrap\",{enumerable:!0,get:function(){return _wrapIdbValue.u}});Object.defineProperty(exports,\"wrap\",{enumerable:!0,get:function(){return _wrapIdbValue.w}});var _wrapIdbValue=require(\"module$node_modules$idb$build$wrap_idb_value\");const readMethods=[\"get\",\"getKey\",\"getAll\",\"getAllKeys\",\"count\"],\nwriteMethods=[\"put\",\"add\",\"delete\",\"clear\"],cachedMethods=new Map;(0,_wrapIdbValue.r)(oldTraps=>Object.assign({},oldTraps,{get:(target,prop,receiver)=>getMethod(target,prop)||oldTraps.get(target,prop,receiver),has:(target,prop)=>!!getMethod(target,prop)||oldTraps.has(target,prop)}))}","~:source","shadow$provide[\"module$node_modules$idb$build$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deleteDB = deleteDB;\nexports.openDB = openDB;\nObject.defineProperty(exports, \"unwrap\", {\n  enumerable: true,\n  get: function () {\n    return _wrapIdbValue.u;\n  }\n});\nObject.defineProperty(exports, \"wrap\", {\n  enumerable: true,\n  get: function () {\n    return _wrapIdbValue.w;\n  }\n});\n\nvar _wrapIdbValue = require(\"./wrap-idb-value.js\");\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, {\n  blocked,\n  upgrade,\n  blocking,\n  terminated\n} = {}) {\n  const request = indexedDB.open(name, version);\n  const openPromise = (0, _wrapIdbValue.w)(request);\n\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', event => {\n      upgrade((0, _wrapIdbValue.w)(request.result), event.oldVersion, event.newVersion, (0, _wrapIdbValue.w)(request.transaction));\n    });\n  }\n\n  if (blocked) request.addEventListener('blocked', () => blocked());\n  openPromise.then(db => {\n    if (terminated) db.addEventListener('close', () => terminated());\n    if (blocking) db.addEventListener('versionchange', () => blocking());\n  }).catch(() => {});\n  return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\n\n\nfunction deleteDB(name, {\n  blocked\n} = {}) {\n  const request = indexedDB.deleteDatabase(name);\n  if (blocked) request.addEventListener('blocked', () => blocked());\n  return (0, _wrapIdbValue.w)(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\n\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n    return;\n  }\n\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, '');\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n\n  if ( // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n    return;\n  }\n\n  const method = async function (storeName, ...args) {\n    // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n    let target = tx.store;\n    if (useIndex) target = target.index(args.shift()); // Must reject if op rejects.\n    // If it's a write operation, must reject if tx.done rejects.\n    // Must reject with op rejection first.\n    // Must resolve with op value.\n    // Must handle both promises (no unhandled rejections)\n\n    return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\n  };\n\n  cachedMethods.set(prop, method);\n  return method;\n}\n\n(0, _wrapIdbValue.r)(oldTraps => ({ ...oldTraps,\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$idb$build$wrap_idb_value","~$shadow.js"]],"~:properties",["^5",["__esModule","unwrap","openDB","wrap","value","enumerable","deleteDB","has","get"]],"~:compiled-at",1666337898749,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$idb$build$index.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/idb/build/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$idb$build$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.deleteDB = deleteDB;\\nexports.openDB = openDB;\\nObject.defineProperty(exports, \\\"unwrap\\\", {\\n  enumerable: true,\\n  get: function () {\\n    return _wrapIdbValue.u;\\n  }\\n});\\nObject.defineProperty(exports, \\\"wrap\\\", {\\n  enumerable: true,\\n  get: function () {\\n    return _wrapIdbValue.w;\\n  }\\n});\\n\\nvar _wrapIdbValue = require(\\\"./wrap-idb-value.js\\\");\\n\\n/**\\n * Open a database.\\n *\\n * @param name Name of the database.\\n * @param version Schema version.\\n * @param callbacks Additional callbacks.\\n */\\nfunction openDB(name, version, {\\n  blocked,\\n  upgrade,\\n  blocking,\\n  terminated\\n} = {}) {\\n  const request = indexedDB.open(name, version);\\n  const openPromise = (0, _wrapIdbValue.w)(request);\\n\\n  if (upgrade) {\\n    request.addEventListener('upgradeneeded', event => {\\n      upgrade((0, _wrapIdbValue.w)(request.result), event.oldVersion, event.newVersion, (0, _wrapIdbValue.w)(request.transaction));\\n    });\\n  }\\n\\n  if (blocked) request.addEventListener('blocked', () => blocked());\\n  openPromise.then(db => {\\n    if (terminated) db.addEventListener('close', () => terminated());\\n    if (blocking) db.addEventListener('versionchange', () => blocking());\\n  }).catch(() => {});\\n  return openPromise;\\n}\\n/**\\n * Delete a database.\\n *\\n * @param name Name of the database.\\n */\\n\\n\\nfunction deleteDB(name, {\\n  blocked\\n} = {}) {\\n  const request = indexedDB.deleteDatabase(name);\\n  if (blocked) request.addEventListener('blocked', () => blocked());\\n  return (0, _wrapIdbValue.w)(request).then(() => undefined);\\n}\\n\\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\\nconst cachedMethods = new Map();\\n\\nfunction getMethod(target, prop) {\\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\\n    return;\\n  }\\n\\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\\n  const targetFuncName = prop.replace(/FromIndex$/, '');\\n  const useIndex = prop !== targetFuncName;\\n  const isWrite = writeMethods.includes(targetFuncName);\\n\\n  if ( // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\\n    return;\\n  }\\n\\n  const method = async function (storeName, ...args) {\\n    // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\\n    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\\n    let target = tx.store;\\n    if (useIndex) target = target.index(args.shift()); // Must reject if op rejects.\\n    // If it's a write operation, must reject if tx.done rejects.\\n    // Must reject with op rejection first.\\n    // Must resolve with op value.\\n    // Must handle both promises (no unhandled rejections)\\n\\n    return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\\n  };\\n\\n  cachedMethods.set(prop, method);\\n  return method;\\n}\\n\\n(0, _wrapIdbValue.r)(oldTraps => ({ ...oldTraps,\\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\\n}));\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getMethod\",\"target\",\"prop\",\"IDBDatabase\",\"cachedMethods\",\"get\",\"targetFuncName\",\"replace\",\"useIndex\",\"isWrite\",\"writeMethods\",\"includes\",\"prototype\",\"IDBIndex\",\"IDBObjectStore\",\"readMethods\",\"method\",\"storeName\",\"args\",\"tx\",\"transaction\",\"store\",\"index\",\"shift\",\"Promise\",\"all\",\"done\",\"set\",\"Object\",\"defineProperty\",\"value\",\"deleteDB\",\"name\",\"blocked\",\"request\",\"indexedDB\",\"deleteDatabase\",\"addEventListener\",\"_wrapIdbValue\",\"w\",\"then\",\"undefined\",\"openDB\",\"version\",\"upgrade\",\"blocking\",\"terminated\",\"open\",\"openPromise\",\"event\",\"result\",\"oldVersion\",\"newVersion\",\"db\",\"catch\",\"enumerable\",\"u\",\"Map\",\"r\",\"oldTraps\",\"receiver\",\"has\"]\n}\n"]